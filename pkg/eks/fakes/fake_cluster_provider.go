// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
	"github.com/weaveworks/eksctl/pkg/cfn/manager"
	"github.com/weaveworks/eksctl/pkg/eks"
	iamoidc "github.com/weaveworks/eksctl/pkg/iam/oidc"
	"github.com/weaveworks/eksctl/pkg/kubernetes"
	"github.com/weaveworks/eksctl/pkg/utils/tasks"
	kubernetesa "k8s.io/client-go/kubernetes"
)

type FakeClusterProvider struct {
	AWSProviderStub        func() v1alpha5.AWSProvider
	aWSProviderMutex       sync.RWMutex
	aWSProviderArgsForCall []struct {
	}
	aWSProviderReturns struct {
		result1 v1alpha5.AWSProvider
	}
	aWSProviderReturnsOnCall map[int]struct {
		result1 v1alpha5.AWSProvider
	}
	ClusterTasksForNodeGroupsStub        func(*v1alpha5.ClusterConfig, bool, bool) *tasks.TaskTree
	clusterTasksForNodeGroupsMutex       sync.RWMutex
	clusterTasksForNodeGroupsArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 bool
		arg3 bool
	}
	clusterTasksForNodeGroupsReturns struct {
		result1 *tasks.TaskTree
	}
	clusterTasksForNodeGroupsReturnsOnCall map[int]struct {
		result1 *tasks.TaskTree
	}
	ControlPlaneVersionStub        func() string
	controlPlaneVersionMutex       sync.RWMutex
	controlPlaneVersionArgsForCall []struct {
	}
	controlPlaneVersionReturns struct {
		result1 string
	}
	controlPlaneVersionReturnsOnCall map[int]struct {
		result1 string
	}
	GetUsernameStub        func() string
	getUsernameMutex       sync.RWMutex
	getUsernameArgsForCall []struct {
	}
	getUsernameReturns struct {
		result1 string
	}
	getUsernameReturnsOnCall map[int]struct {
		result1 string
	}
	KubeProviderStub        func() eks.KubeProvider
	kubeProviderMutex       sync.RWMutex
	kubeProviderArgsForCall []struct {
	}
	kubeProviderReturns struct {
		result1 eks.KubeProvider
	}
	kubeProviderReturnsOnCall map[int]struct {
		result1 eks.KubeProvider
	}
	LoadClusterIntoSpecFromStackStub        func(*v1alpha5.ClusterConfig, manager.StackManager) error
	loadClusterIntoSpecFromStackMutex       sync.RWMutex
	loadClusterIntoSpecFromStackArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 manager.StackManager
	}
	loadClusterIntoSpecFromStackReturns struct {
		result1 error
	}
	loadClusterIntoSpecFromStackReturnsOnCall map[int]struct {
		result1 error
	}
	NewClientStub        func(*v1alpha5.ClusterConfig) (kubernetes.ClientInterface, error)
	newClientMutex       sync.RWMutex
	newClientArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	newClientReturns struct {
		result1 kubernetes.ClientInterface
		result2 error
	}
	newClientReturnsOnCall map[int]struct {
		result1 kubernetes.ClientInterface
		result2 error
	}
	NewOpenIDConnectManagerStub        func(*v1alpha5.ClusterConfig) (*iamoidc.OpenIDConnectManager, error)
	newOpenIDConnectManagerMutex       sync.RWMutex
	newOpenIDConnectManagerArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	newOpenIDConnectManagerReturns struct {
		result1 *iamoidc.OpenIDConnectManager
		result2 error
	}
	newOpenIDConnectManagerReturnsOnCall map[int]struct {
		result1 *iamoidc.OpenIDConnectManager
		result2 error
	}
	NewRawClientStub        func(*v1alpha5.ClusterConfig) (kubernetes.RawClientInterface, error)
	newRawClientMutex       sync.RWMutex
	newRawClientArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	newRawClientReturns struct {
		result1 kubernetes.RawClientInterface
		result2 error
	}
	newRawClientReturnsOnCall map[int]struct {
		result1 kubernetes.RawClientInterface
		result2 error
	}
	NewStackManagerStub        func(*v1alpha5.ClusterConfig) manager.StackManager
	newStackManagerMutex       sync.RWMutex
	newStackManagerArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	newStackManagerReturns struct {
		result1 manager.StackManager
	}
	newStackManagerReturnsOnCall map[int]struct {
		result1 manager.StackManager
	}
	NewStdClientSetStub        func(*v1alpha5.ClusterConfig) (kubernetesa.Interface, error)
	newStdClientSetMutex       sync.RWMutex
	newStdClientSetArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	newStdClientSetReturns struct {
		result1 kubernetesa.Interface
		result2 error
	}
	newStdClientSetReturnsOnCall map[int]struct {
		result1 kubernetesa.Interface
		result2 error
	}
	ServerVersionStub        func(kubernetes.RawClientInterface) (string, error)
	serverVersionMutex       sync.RWMutex
	serverVersionArgsForCall []struct {
		arg1 kubernetes.RawClientInterface
	}
	serverVersionReturns struct {
		result1 string
		result2 error
	}
	serverVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StatusStub        func() *eks.ProviderStatus
	statusMutex       sync.RWMutex
	statusArgsForCall []struct {
	}
	statusReturns struct {
		result1 *eks.ProviderStatus
	}
	statusReturnsOnCall map[int]struct {
		result1 *eks.ProviderStatus
	}
	SupportsManagedNodesStub        func(*v1alpha5.ClusterConfig) (bool, error)
	supportsManagedNodesMutex       sync.RWMutex
	supportsManagedNodesArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
	}
	supportsManagedNodesReturns struct {
		result1 bool
		result2 error
	}
	supportsManagedNodesReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateAuthConfigMapStub        func([]*v1alpha5.NodeGroup, kubernetesa.Interface) error
	updateAuthConfigMapMutex       sync.RWMutex
	updateAuthConfigMapArgsForCall []struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 kubernetesa.Interface
	}
	updateAuthConfigMapReturns struct {
		result1 error
	}
	updateAuthConfigMapReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateClusterForCompatibilityStub        func(*v1alpha5.ClusterConfig, manager.StackManager) error
	validateClusterForCompatibilityMutex       sync.RWMutex
	validateClusterForCompatibilityArgsForCall []struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 manager.StackManager
	}
	validateClusterForCompatibilityReturns struct {
		result1 error
	}
	validateClusterForCompatibilityReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForNodesStub        func(kubernetesa.Interface, eks.KubeNodeGroup) error
	waitForNodesMutex       sync.RWMutex
	waitForNodesArgsForCall []struct {
		arg1 kubernetesa.Interface
		arg2 eks.KubeNodeGroup
	}
	waitForNodesReturns struct {
		result1 error
	}
	waitForNodesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClusterProvider) AWSProvider() v1alpha5.AWSProvider {
	fake.aWSProviderMutex.Lock()
	ret, specificReturn := fake.aWSProviderReturnsOnCall[len(fake.aWSProviderArgsForCall)]
	fake.aWSProviderArgsForCall = append(fake.aWSProviderArgsForCall, struct {
	}{})
	stub := fake.AWSProviderStub
	fakeReturns := fake.aWSProviderReturns
	fake.recordInvocation("AWSProvider", []interface{}{})
	fake.aWSProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) AWSProviderCallCount() int {
	fake.aWSProviderMutex.RLock()
	defer fake.aWSProviderMutex.RUnlock()
	return len(fake.aWSProviderArgsForCall)
}

func (fake *FakeClusterProvider) AWSProviderCalls(stub func() v1alpha5.AWSProvider) {
	fake.aWSProviderMutex.Lock()
	defer fake.aWSProviderMutex.Unlock()
	fake.AWSProviderStub = stub
}

func (fake *FakeClusterProvider) AWSProviderReturns(result1 v1alpha5.AWSProvider) {
	fake.aWSProviderMutex.Lock()
	defer fake.aWSProviderMutex.Unlock()
	fake.AWSProviderStub = nil
	fake.aWSProviderReturns = struct {
		result1 v1alpha5.AWSProvider
	}{result1}
}

func (fake *FakeClusterProvider) AWSProviderReturnsOnCall(i int, result1 v1alpha5.AWSProvider) {
	fake.aWSProviderMutex.Lock()
	defer fake.aWSProviderMutex.Unlock()
	fake.AWSProviderStub = nil
	if fake.aWSProviderReturnsOnCall == nil {
		fake.aWSProviderReturnsOnCall = make(map[int]struct {
			result1 v1alpha5.AWSProvider
		})
	}
	fake.aWSProviderReturnsOnCall[i] = struct {
		result1 v1alpha5.AWSProvider
	}{result1}
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroups(arg1 *v1alpha5.ClusterConfig, arg2 bool, arg3 bool) *tasks.TaskTree {
	fake.clusterTasksForNodeGroupsMutex.Lock()
	ret, specificReturn := fake.clusterTasksForNodeGroupsReturnsOnCall[len(fake.clusterTasksForNodeGroupsArgsForCall)]
	fake.clusterTasksForNodeGroupsArgsForCall = append(fake.clusterTasksForNodeGroupsArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.ClusterTasksForNodeGroupsStub
	fakeReturns := fake.clusterTasksForNodeGroupsReturns
	fake.recordInvocation("ClusterTasksForNodeGroups", []interface{}{arg1, arg2, arg3})
	fake.clusterTasksForNodeGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroupsCallCount() int {
	fake.clusterTasksForNodeGroupsMutex.RLock()
	defer fake.clusterTasksForNodeGroupsMutex.RUnlock()
	return len(fake.clusterTasksForNodeGroupsArgsForCall)
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroupsCalls(stub func(*v1alpha5.ClusterConfig, bool, bool) *tasks.TaskTree) {
	fake.clusterTasksForNodeGroupsMutex.Lock()
	defer fake.clusterTasksForNodeGroupsMutex.Unlock()
	fake.ClusterTasksForNodeGroupsStub = stub
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroupsArgsForCall(i int) (*v1alpha5.ClusterConfig, bool, bool) {
	fake.clusterTasksForNodeGroupsMutex.RLock()
	defer fake.clusterTasksForNodeGroupsMutex.RUnlock()
	argsForCall := fake.clusterTasksForNodeGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroupsReturns(result1 *tasks.TaskTree) {
	fake.clusterTasksForNodeGroupsMutex.Lock()
	defer fake.clusterTasksForNodeGroupsMutex.Unlock()
	fake.ClusterTasksForNodeGroupsStub = nil
	fake.clusterTasksForNodeGroupsReturns = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeClusterProvider) ClusterTasksForNodeGroupsReturnsOnCall(i int, result1 *tasks.TaskTree) {
	fake.clusterTasksForNodeGroupsMutex.Lock()
	defer fake.clusterTasksForNodeGroupsMutex.Unlock()
	fake.ClusterTasksForNodeGroupsStub = nil
	if fake.clusterTasksForNodeGroupsReturnsOnCall == nil {
		fake.clusterTasksForNodeGroupsReturnsOnCall = make(map[int]struct {
			result1 *tasks.TaskTree
		})
	}
	fake.clusterTasksForNodeGroupsReturnsOnCall[i] = struct {
		result1 *tasks.TaskTree
	}{result1}
}

func (fake *FakeClusterProvider) ControlPlaneVersion() string {
	fake.controlPlaneVersionMutex.Lock()
	ret, specificReturn := fake.controlPlaneVersionReturnsOnCall[len(fake.controlPlaneVersionArgsForCall)]
	fake.controlPlaneVersionArgsForCall = append(fake.controlPlaneVersionArgsForCall, struct {
	}{})
	stub := fake.ControlPlaneVersionStub
	fakeReturns := fake.controlPlaneVersionReturns
	fake.recordInvocation("ControlPlaneVersion", []interface{}{})
	fake.controlPlaneVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) ControlPlaneVersionCallCount() int {
	fake.controlPlaneVersionMutex.RLock()
	defer fake.controlPlaneVersionMutex.RUnlock()
	return len(fake.controlPlaneVersionArgsForCall)
}

func (fake *FakeClusterProvider) ControlPlaneVersionCalls(stub func() string) {
	fake.controlPlaneVersionMutex.Lock()
	defer fake.controlPlaneVersionMutex.Unlock()
	fake.ControlPlaneVersionStub = stub
}

func (fake *FakeClusterProvider) ControlPlaneVersionReturns(result1 string) {
	fake.controlPlaneVersionMutex.Lock()
	defer fake.controlPlaneVersionMutex.Unlock()
	fake.ControlPlaneVersionStub = nil
	fake.controlPlaneVersionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterProvider) ControlPlaneVersionReturnsOnCall(i int, result1 string) {
	fake.controlPlaneVersionMutex.Lock()
	defer fake.controlPlaneVersionMutex.Unlock()
	fake.ControlPlaneVersionStub = nil
	if fake.controlPlaneVersionReturnsOnCall == nil {
		fake.controlPlaneVersionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.controlPlaneVersionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterProvider) GetUsername() string {
	fake.getUsernameMutex.Lock()
	ret, specificReturn := fake.getUsernameReturnsOnCall[len(fake.getUsernameArgsForCall)]
	fake.getUsernameArgsForCall = append(fake.getUsernameArgsForCall, struct {
	}{})
	stub := fake.GetUsernameStub
	fakeReturns := fake.getUsernameReturns
	fake.recordInvocation("GetUsername", []interface{}{})
	fake.getUsernameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) GetUsernameCallCount() int {
	fake.getUsernameMutex.RLock()
	defer fake.getUsernameMutex.RUnlock()
	return len(fake.getUsernameArgsForCall)
}

func (fake *FakeClusterProvider) GetUsernameCalls(stub func() string) {
	fake.getUsernameMutex.Lock()
	defer fake.getUsernameMutex.Unlock()
	fake.GetUsernameStub = stub
}

func (fake *FakeClusterProvider) GetUsernameReturns(result1 string) {
	fake.getUsernameMutex.Lock()
	defer fake.getUsernameMutex.Unlock()
	fake.GetUsernameStub = nil
	fake.getUsernameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterProvider) GetUsernameReturnsOnCall(i int, result1 string) {
	fake.getUsernameMutex.Lock()
	defer fake.getUsernameMutex.Unlock()
	fake.GetUsernameStub = nil
	if fake.getUsernameReturnsOnCall == nil {
		fake.getUsernameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUsernameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeClusterProvider) KubeProvider() eks.KubeProvider {
	fake.kubeProviderMutex.Lock()
	ret, specificReturn := fake.kubeProviderReturnsOnCall[len(fake.kubeProviderArgsForCall)]
	fake.kubeProviderArgsForCall = append(fake.kubeProviderArgsForCall, struct {
	}{})
	stub := fake.KubeProviderStub
	fakeReturns := fake.kubeProviderReturns
	fake.recordInvocation("KubeProvider", []interface{}{})
	fake.kubeProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) KubeProviderCallCount() int {
	fake.kubeProviderMutex.RLock()
	defer fake.kubeProviderMutex.RUnlock()
	return len(fake.kubeProviderArgsForCall)
}

func (fake *FakeClusterProvider) KubeProviderCalls(stub func() eks.KubeProvider) {
	fake.kubeProviderMutex.Lock()
	defer fake.kubeProviderMutex.Unlock()
	fake.KubeProviderStub = stub
}

func (fake *FakeClusterProvider) KubeProviderReturns(result1 eks.KubeProvider) {
	fake.kubeProviderMutex.Lock()
	defer fake.kubeProviderMutex.Unlock()
	fake.KubeProviderStub = nil
	fake.kubeProviderReturns = struct {
		result1 eks.KubeProvider
	}{result1}
}

func (fake *FakeClusterProvider) KubeProviderReturnsOnCall(i int, result1 eks.KubeProvider) {
	fake.kubeProviderMutex.Lock()
	defer fake.kubeProviderMutex.Unlock()
	fake.KubeProviderStub = nil
	if fake.kubeProviderReturnsOnCall == nil {
		fake.kubeProviderReturnsOnCall = make(map[int]struct {
			result1 eks.KubeProvider
		})
	}
	fake.kubeProviderReturnsOnCall[i] = struct {
		result1 eks.KubeProvider
	}{result1}
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStack(arg1 *v1alpha5.ClusterConfig, arg2 manager.StackManager) error {
	fake.loadClusterIntoSpecFromStackMutex.Lock()
	ret, specificReturn := fake.loadClusterIntoSpecFromStackReturnsOnCall[len(fake.loadClusterIntoSpecFromStackArgsForCall)]
	fake.loadClusterIntoSpecFromStackArgsForCall = append(fake.loadClusterIntoSpecFromStackArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 manager.StackManager
	}{arg1, arg2})
	stub := fake.LoadClusterIntoSpecFromStackStub
	fakeReturns := fake.loadClusterIntoSpecFromStackReturns
	fake.recordInvocation("LoadClusterIntoSpecFromStack", []interface{}{arg1, arg2})
	fake.loadClusterIntoSpecFromStackMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStackCallCount() int {
	fake.loadClusterIntoSpecFromStackMutex.RLock()
	defer fake.loadClusterIntoSpecFromStackMutex.RUnlock()
	return len(fake.loadClusterIntoSpecFromStackArgsForCall)
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStackCalls(stub func(*v1alpha5.ClusterConfig, manager.StackManager) error) {
	fake.loadClusterIntoSpecFromStackMutex.Lock()
	defer fake.loadClusterIntoSpecFromStackMutex.Unlock()
	fake.LoadClusterIntoSpecFromStackStub = stub
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStackArgsForCall(i int) (*v1alpha5.ClusterConfig, manager.StackManager) {
	fake.loadClusterIntoSpecFromStackMutex.RLock()
	defer fake.loadClusterIntoSpecFromStackMutex.RUnlock()
	argsForCall := fake.loadClusterIntoSpecFromStackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStackReturns(result1 error) {
	fake.loadClusterIntoSpecFromStackMutex.Lock()
	defer fake.loadClusterIntoSpecFromStackMutex.Unlock()
	fake.LoadClusterIntoSpecFromStackStub = nil
	fake.loadClusterIntoSpecFromStackReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) LoadClusterIntoSpecFromStackReturnsOnCall(i int, result1 error) {
	fake.loadClusterIntoSpecFromStackMutex.Lock()
	defer fake.loadClusterIntoSpecFromStackMutex.Unlock()
	fake.LoadClusterIntoSpecFromStackStub = nil
	if fake.loadClusterIntoSpecFromStackReturnsOnCall == nil {
		fake.loadClusterIntoSpecFromStackReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadClusterIntoSpecFromStackReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) NewClient(arg1 *v1alpha5.ClusterConfig) (kubernetes.ClientInterface, error) {
	fake.newClientMutex.Lock()
	ret, specificReturn := fake.newClientReturnsOnCall[len(fake.newClientArgsForCall)]
	fake.newClientArgsForCall = append(fake.newClientArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.NewClientStub
	fakeReturns := fake.newClientReturns
	fake.recordInvocation("NewClient", []interface{}{arg1})
	fake.newClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) NewClientCallCount() int {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	return len(fake.newClientArgsForCall)
}

func (fake *FakeClusterProvider) NewClientCalls(stub func(*v1alpha5.ClusterConfig) (kubernetes.ClientInterface, error)) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = stub
}

func (fake *FakeClusterProvider) NewClientArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	argsForCall := fake.newClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) NewClientReturns(result1 kubernetes.ClientInterface, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	fake.newClientReturns = struct {
		result1 kubernetes.ClientInterface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewClientReturnsOnCall(i int, result1 kubernetes.ClientInterface, result2 error) {
	fake.newClientMutex.Lock()
	defer fake.newClientMutex.Unlock()
	fake.NewClientStub = nil
	if fake.newClientReturnsOnCall == nil {
		fake.newClientReturnsOnCall = make(map[int]struct {
			result1 kubernetes.ClientInterface
			result2 error
		})
	}
	fake.newClientReturnsOnCall[i] = struct {
		result1 kubernetes.ClientInterface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewOpenIDConnectManager(arg1 *v1alpha5.ClusterConfig) (*iamoidc.OpenIDConnectManager, error) {
	fake.newOpenIDConnectManagerMutex.Lock()
	ret, specificReturn := fake.newOpenIDConnectManagerReturnsOnCall[len(fake.newOpenIDConnectManagerArgsForCall)]
	fake.newOpenIDConnectManagerArgsForCall = append(fake.newOpenIDConnectManagerArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.NewOpenIDConnectManagerStub
	fakeReturns := fake.newOpenIDConnectManagerReturns
	fake.recordInvocation("NewOpenIDConnectManager", []interface{}{arg1})
	fake.newOpenIDConnectManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) NewOpenIDConnectManagerCallCount() int {
	fake.newOpenIDConnectManagerMutex.RLock()
	defer fake.newOpenIDConnectManagerMutex.RUnlock()
	return len(fake.newOpenIDConnectManagerArgsForCall)
}

func (fake *FakeClusterProvider) NewOpenIDConnectManagerCalls(stub func(*v1alpha5.ClusterConfig) (*iamoidc.OpenIDConnectManager, error)) {
	fake.newOpenIDConnectManagerMutex.Lock()
	defer fake.newOpenIDConnectManagerMutex.Unlock()
	fake.NewOpenIDConnectManagerStub = stub
}

func (fake *FakeClusterProvider) NewOpenIDConnectManagerArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.newOpenIDConnectManagerMutex.RLock()
	defer fake.newOpenIDConnectManagerMutex.RUnlock()
	argsForCall := fake.newOpenIDConnectManagerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) NewOpenIDConnectManagerReturns(result1 *iamoidc.OpenIDConnectManager, result2 error) {
	fake.newOpenIDConnectManagerMutex.Lock()
	defer fake.newOpenIDConnectManagerMutex.Unlock()
	fake.NewOpenIDConnectManagerStub = nil
	fake.newOpenIDConnectManagerReturns = struct {
		result1 *iamoidc.OpenIDConnectManager
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewOpenIDConnectManagerReturnsOnCall(i int, result1 *iamoidc.OpenIDConnectManager, result2 error) {
	fake.newOpenIDConnectManagerMutex.Lock()
	defer fake.newOpenIDConnectManagerMutex.Unlock()
	fake.NewOpenIDConnectManagerStub = nil
	if fake.newOpenIDConnectManagerReturnsOnCall == nil {
		fake.newOpenIDConnectManagerReturnsOnCall = make(map[int]struct {
			result1 *iamoidc.OpenIDConnectManager
			result2 error
		})
	}
	fake.newOpenIDConnectManagerReturnsOnCall[i] = struct {
		result1 *iamoidc.OpenIDConnectManager
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewRawClient(arg1 *v1alpha5.ClusterConfig) (kubernetes.RawClientInterface, error) {
	fake.newRawClientMutex.Lock()
	ret, specificReturn := fake.newRawClientReturnsOnCall[len(fake.newRawClientArgsForCall)]
	fake.newRawClientArgsForCall = append(fake.newRawClientArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.NewRawClientStub
	fakeReturns := fake.newRawClientReturns
	fake.recordInvocation("NewRawClient", []interface{}{arg1})
	fake.newRawClientMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) NewRawClientCallCount() int {
	fake.newRawClientMutex.RLock()
	defer fake.newRawClientMutex.RUnlock()
	return len(fake.newRawClientArgsForCall)
}

func (fake *FakeClusterProvider) NewRawClientCalls(stub func(*v1alpha5.ClusterConfig) (kubernetes.RawClientInterface, error)) {
	fake.newRawClientMutex.Lock()
	defer fake.newRawClientMutex.Unlock()
	fake.NewRawClientStub = stub
}

func (fake *FakeClusterProvider) NewRawClientArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.newRawClientMutex.RLock()
	defer fake.newRawClientMutex.RUnlock()
	argsForCall := fake.newRawClientArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) NewRawClientReturns(result1 kubernetes.RawClientInterface, result2 error) {
	fake.newRawClientMutex.Lock()
	defer fake.newRawClientMutex.Unlock()
	fake.NewRawClientStub = nil
	fake.newRawClientReturns = struct {
		result1 kubernetes.RawClientInterface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewRawClientReturnsOnCall(i int, result1 kubernetes.RawClientInterface, result2 error) {
	fake.newRawClientMutex.Lock()
	defer fake.newRawClientMutex.Unlock()
	fake.NewRawClientStub = nil
	if fake.newRawClientReturnsOnCall == nil {
		fake.newRawClientReturnsOnCall = make(map[int]struct {
			result1 kubernetes.RawClientInterface
			result2 error
		})
	}
	fake.newRawClientReturnsOnCall[i] = struct {
		result1 kubernetes.RawClientInterface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewStackManager(arg1 *v1alpha5.ClusterConfig) manager.StackManager {
	fake.newStackManagerMutex.Lock()
	ret, specificReturn := fake.newStackManagerReturnsOnCall[len(fake.newStackManagerArgsForCall)]
	fake.newStackManagerArgsForCall = append(fake.newStackManagerArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.NewStackManagerStub
	fakeReturns := fake.newStackManagerReturns
	fake.recordInvocation("NewStackManager", []interface{}{arg1})
	fake.newStackManagerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) NewStackManagerCallCount() int {
	fake.newStackManagerMutex.RLock()
	defer fake.newStackManagerMutex.RUnlock()
	return len(fake.newStackManagerArgsForCall)
}

func (fake *FakeClusterProvider) NewStackManagerCalls(stub func(*v1alpha5.ClusterConfig) manager.StackManager) {
	fake.newStackManagerMutex.Lock()
	defer fake.newStackManagerMutex.Unlock()
	fake.NewStackManagerStub = stub
}

func (fake *FakeClusterProvider) NewStackManagerArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.newStackManagerMutex.RLock()
	defer fake.newStackManagerMutex.RUnlock()
	argsForCall := fake.newStackManagerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) NewStackManagerReturns(result1 manager.StackManager) {
	fake.newStackManagerMutex.Lock()
	defer fake.newStackManagerMutex.Unlock()
	fake.NewStackManagerStub = nil
	fake.newStackManagerReturns = struct {
		result1 manager.StackManager
	}{result1}
}

func (fake *FakeClusterProvider) NewStackManagerReturnsOnCall(i int, result1 manager.StackManager) {
	fake.newStackManagerMutex.Lock()
	defer fake.newStackManagerMutex.Unlock()
	fake.NewStackManagerStub = nil
	if fake.newStackManagerReturnsOnCall == nil {
		fake.newStackManagerReturnsOnCall = make(map[int]struct {
			result1 manager.StackManager
		})
	}
	fake.newStackManagerReturnsOnCall[i] = struct {
		result1 manager.StackManager
	}{result1}
}

func (fake *FakeClusterProvider) NewStdClientSet(arg1 *v1alpha5.ClusterConfig) (kubernetesa.Interface, error) {
	fake.newStdClientSetMutex.Lock()
	ret, specificReturn := fake.newStdClientSetReturnsOnCall[len(fake.newStdClientSetArgsForCall)]
	fake.newStdClientSetArgsForCall = append(fake.newStdClientSetArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.NewStdClientSetStub
	fakeReturns := fake.newStdClientSetReturns
	fake.recordInvocation("NewStdClientSet", []interface{}{arg1})
	fake.newStdClientSetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) NewStdClientSetCallCount() int {
	fake.newStdClientSetMutex.RLock()
	defer fake.newStdClientSetMutex.RUnlock()
	return len(fake.newStdClientSetArgsForCall)
}

func (fake *FakeClusterProvider) NewStdClientSetCalls(stub func(*v1alpha5.ClusterConfig) (kubernetesa.Interface, error)) {
	fake.newStdClientSetMutex.Lock()
	defer fake.newStdClientSetMutex.Unlock()
	fake.NewStdClientSetStub = stub
}

func (fake *FakeClusterProvider) NewStdClientSetArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.newStdClientSetMutex.RLock()
	defer fake.newStdClientSetMutex.RUnlock()
	argsForCall := fake.newStdClientSetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) NewStdClientSetReturns(result1 kubernetesa.Interface, result2 error) {
	fake.newStdClientSetMutex.Lock()
	defer fake.newStdClientSetMutex.Unlock()
	fake.NewStdClientSetStub = nil
	fake.newStdClientSetReturns = struct {
		result1 kubernetesa.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) NewStdClientSetReturnsOnCall(i int, result1 kubernetesa.Interface, result2 error) {
	fake.newStdClientSetMutex.Lock()
	defer fake.newStdClientSetMutex.Unlock()
	fake.NewStdClientSetStub = nil
	if fake.newStdClientSetReturnsOnCall == nil {
		fake.newStdClientSetReturnsOnCall = make(map[int]struct {
			result1 kubernetesa.Interface
			result2 error
		})
	}
	fake.newStdClientSetReturnsOnCall[i] = struct {
		result1 kubernetesa.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) ServerVersion(arg1 kubernetes.RawClientInterface) (string, error) {
	fake.serverVersionMutex.Lock()
	ret, specificReturn := fake.serverVersionReturnsOnCall[len(fake.serverVersionArgsForCall)]
	fake.serverVersionArgsForCall = append(fake.serverVersionArgsForCall, struct {
		arg1 kubernetes.RawClientInterface
	}{arg1})
	stub := fake.ServerVersionStub
	fakeReturns := fake.serverVersionReturns
	fake.recordInvocation("ServerVersion", []interface{}{arg1})
	fake.serverVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) ServerVersionCallCount() int {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	return len(fake.serverVersionArgsForCall)
}

func (fake *FakeClusterProvider) ServerVersionCalls(stub func(kubernetes.RawClientInterface) (string, error)) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = stub
}

func (fake *FakeClusterProvider) ServerVersionArgsForCall(i int) kubernetes.RawClientInterface {
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	argsForCall := fake.serverVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) ServerVersionReturns(result1 string, result2 error) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	fake.serverVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) ServerVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.serverVersionMutex.Lock()
	defer fake.serverVersionMutex.Unlock()
	fake.ServerVersionStub = nil
	if fake.serverVersionReturnsOnCall == nil {
		fake.serverVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.serverVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) Status() *eks.ProviderStatus {
	fake.statusMutex.Lock()
	ret, specificReturn := fake.statusReturnsOnCall[len(fake.statusArgsForCall)]
	fake.statusArgsForCall = append(fake.statusArgsForCall, struct {
	}{})
	stub := fake.StatusStub
	fakeReturns := fake.statusReturns
	fake.recordInvocation("Status", []interface{}{})
	fake.statusMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) StatusCallCount() int {
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	return len(fake.statusArgsForCall)
}

func (fake *FakeClusterProvider) StatusCalls(stub func() *eks.ProviderStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = stub
}

func (fake *FakeClusterProvider) StatusReturns(result1 *eks.ProviderStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	fake.statusReturns = struct {
		result1 *eks.ProviderStatus
	}{result1}
}

func (fake *FakeClusterProvider) StatusReturnsOnCall(i int, result1 *eks.ProviderStatus) {
	fake.statusMutex.Lock()
	defer fake.statusMutex.Unlock()
	fake.StatusStub = nil
	if fake.statusReturnsOnCall == nil {
		fake.statusReturnsOnCall = make(map[int]struct {
			result1 *eks.ProviderStatus
		})
	}
	fake.statusReturnsOnCall[i] = struct {
		result1 *eks.ProviderStatus
	}{result1}
}

func (fake *FakeClusterProvider) SupportsManagedNodes(arg1 *v1alpha5.ClusterConfig) (bool, error) {
	fake.supportsManagedNodesMutex.Lock()
	ret, specificReturn := fake.supportsManagedNodesReturnsOnCall[len(fake.supportsManagedNodesArgsForCall)]
	fake.supportsManagedNodesArgsForCall = append(fake.supportsManagedNodesArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
	}{arg1})
	stub := fake.SupportsManagedNodesStub
	fakeReturns := fake.supportsManagedNodesReturns
	fake.recordInvocation("SupportsManagedNodes", []interface{}{arg1})
	fake.supportsManagedNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClusterProvider) SupportsManagedNodesCallCount() int {
	fake.supportsManagedNodesMutex.RLock()
	defer fake.supportsManagedNodesMutex.RUnlock()
	return len(fake.supportsManagedNodesArgsForCall)
}

func (fake *FakeClusterProvider) SupportsManagedNodesCalls(stub func(*v1alpha5.ClusterConfig) (bool, error)) {
	fake.supportsManagedNodesMutex.Lock()
	defer fake.supportsManagedNodesMutex.Unlock()
	fake.SupportsManagedNodesStub = stub
}

func (fake *FakeClusterProvider) SupportsManagedNodesArgsForCall(i int) *v1alpha5.ClusterConfig {
	fake.supportsManagedNodesMutex.RLock()
	defer fake.supportsManagedNodesMutex.RUnlock()
	argsForCall := fake.supportsManagedNodesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClusterProvider) SupportsManagedNodesReturns(result1 bool, result2 error) {
	fake.supportsManagedNodesMutex.Lock()
	defer fake.supportsManagedNodesMutex.Unlock()
	fake.SupportsManagedNodesStub = nil
	fake.supportsManagedNodesReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) SupportsManagedNodesReturnsOnCall(i int, result1 bool, result2 error) {
	fake.supportsManagedNodesMutex.Lock()
	defer fake.supportsManagedNodesMutex.Unlock()
	fake.SupportsManagedNodesStub = nil
	if fake.supportsManagedNodesReturnsOnCall == nil {
		fake.supportsManagedNodesReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.supportsManagedNodesReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterProvider) UpdateAuthConfigMap(arg1 []*v1alpha5.NodeGroup, arg2 kubernetesa.Interface) error {
	var arg1Copy []*v1alpha5.NodeGroup
	if arg1 != nil {
		arg1Copy = make([]*v1alpha5.NodeGroup, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.updateAuthConfigMapMutex.Lock()
	ret, specificReturn := fake.updateAuthConfigMapReturnsOnCall[len(fake.updateAuthConfigMapArgsForCall)]
	fake.updateAuthConfigMapArgsForCall = append(fake.updateAuthConfigMapArgsForCall, struct {
		arg1 []*v1alpha5.NodeGroup
		arg2 kubernetesa.Interface
	}{arg1Copy, arg2})
	stub := fake.UpdateAuthConfigMapStub
	fakeReturns := fake.updateAuthConfigMapReturns
	fake.recordInvocation("UpdateAuthConfigMap", []interface{}{arg1Copy, arg2})
	fake.updateAuthConfigMapMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) UpdateAuthConfigMapCallCount() int {
	fake.updateAuthConfigMapMutex.RLock()
	defer fake.updateAuthConfigMapMutex.RUnlock()
	return len(fake.updateAuthConfigMapArgsForCall)
}

func (fake *FakeClusterProvider) UpdateAuthConfigMapCalls(stub func([]*v1alpha5.NodeGroup, kubernetesa.Interface) error) {
	fake.updateAuthConfigMapMutex.Lock()
	defer fake.updateAuthConfigMapMutex.Unlock()
	fake.UpdateAuthConfigMapStub = stub
}

func (fake *FakeClusterProvider) UpdateAuthConfigMapArgsForCall(i int) ([]*v1alpha5.NodeGroup, kubernetesa.Interface) {
	fake.updateAuthConfigMapMutex.RLock()
	defer fake.updateAuthConfigMapMutex.RUnlock()
	argsForCall := fake.updateAuthConfigMapArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterProvider) UpdateAuthConfigMapReturns(result1 error) {
	fake.updateAuthConfigMapMutex.Lock()
	defer fake.updateAuthConfigMapMutex.Unlock()
	fake.UpdateAuthConfigMapStub = nil
	fake.updateAuthConfigMapReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) UpdateAuthConfigMapReturnsOnCall(i int, result1 error) {
	fake.updateAuthConfigMapMutex.Lock()
	defer fake.updateAuthConfigMapMutex.Unlock()
	fake.UpdateAuthConfigMapStub = nil
	if fake.updateAuthConfigMapReturnsOnCall == nil {
		fake.updateAuthConfigMapReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateAuthConfigMapReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibility(arg1 *v1alpha5.ClusterConfig, arg2 manager.StackManager) error {
	fake.validateClusterForCompatibilityMutex.Lock()
	ret, specificReturn := fake.validateClusterForCompatibilityReturnsOnCall[len(fake.validateClusterForCompatibilityArgsForCall)]
	fake.validateClusterForCompatibilityArgsForCall = append(fake.validateClusterForCompatibilityArgsForCall, struct {
		arg1 *v1alpha5.ClusterConfig
		arg2 manager.StackManager
	}{arg1, arg2})
	stub := fake.ValidateClusterForCompatibilityStub
	fakeReturns := fake.validateClusterForCompatibilityReturns
	fake.recordInvocation("ValidateClusterForCompatibility", []interface{}{arg1, arg2})
	fake.validateClusterForCompatibilityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibilityCallCount() int {
	fake.validateClusterForCompatibilityMutex.RLock()
	defer fake.validateClusterForCompatibilityMutex.RUnlock()
	return len(fake.validateClusterForCompatibilityArgsForCall)
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibilityCalls(stub func(*v1alpha5.ClusterConfig, manager.StackManager) error) {
	fake.validateClusterForCompatibilityMutex.Lock()
	defer fake.validateClusterForCompatibilityMutex.Unlock()
	fake.ValidateClusterForCompatibilityStub = stub
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibilityArgsForCall(i int) (*v1alpha5.ClusterConfig, manager.StackManager) {
	fake.validateClusterForCompatibilityMutex.RLock()
	defer fake.validateClusterForCompatibilityMutex.RUnlock()
	argsForCall := fake.validateClusterForCompatibilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibilityReturns(result1 error) {
	fake.validateClusterForCompatibilityMutex.Lock()
	defer fake.validateClusterForCompatibilityMutex.Unlock()
	fake.ValidateClusterForCompatibilityStub = nil
	fake.validateClusterForCompatibilityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) ValidateClusterForCompatibilityReturnsOnCall(i int, result1 error) {
	fake.validateClusterForCompatibilityMutex.Lock()
	defer fake.validateClusterForCompatibilityMutex.Unlock()
	fake.ValidateClusterForCompatibilityStub = nil
	if fake.validateClusterForCompatibilityReturnsOnCall == nil {
		fake.validateClusterForCompatibilityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateClusterForCompatibilityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) WaitForNodes(arg1 kubernetesa.Interface, arg2 eks.KubeNodeGroup) error {
	fake.waitForNodesMutex.Lock()
	ret, specificReturn := fake.waitForNodesReturnsOnCall[len(fake.waitForNodesArgsForCall)]
	fake.waitForNodesArgsForCall = append(fake.waitForNodesArgsForCall, struct {
		arg1 kubernetesa.Interface
		arg2 eks.KubeNodeGroup
	}{arg1, arg2})
	stub := fake.WaitForNodesStub
	fakeReturns := fake.waitForNodesReturns
	fake.recordInvocation("WaitForNodes", []interface{}{arg1, arg2})
	fake.waitForNodesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClusterProvider) WaitForNodesCallCount() int {
	fake.waitForNodesMutex.RLock()
	defer fake.waitForNodesMutex.RUnlock()
	return len(fake.waitForNodesArgsForCall)
}

func (fake *FakeClusterProvider) WaitForNodesCalls(stub func(kubernetesa.Interface, eks.KubeNodeGroup) error) {
	fake.waitForNodesMutex.Lock()
	defer fake.waitForNodesMutex.Unlock()
	fake.WaitForNodesStub = stub
}

func (fake *FakeClusterProvider) WaitForNodesArgsForCall(i int) (kubernetesa.Interface, eks.KubeNodeGroup) {
	fake.waitForNodesMutex.RLock()
	defer fake.waitForNodesMutex.RUnlock()
	argsForCall := fake.waitForNodesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClusterProvider) WaitForNodesReturns(result1 error) {
	fake.waitForNodesMutex.Lock()
	defer fake.waitForNodesMutex.Unlock()
	fake.WaitForNodesStub = nil
	fake.waitForNodesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) WaitForNodesReturnsOnCall(i int, result1 error) {
	fake.waitForNodesMutex.Lock()
	defer fake.waitForNodesMutex.Unlock()
	fake.WaitForNodesStub = nil
	if fake.waitForNodesReturnsOnCall == nil {
		fake.waitForNodesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForNodesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.aWSProviderMutex.RLock()
	defer fake.aWSProviderMutex.RUnlock()
	fake.clusterTasksForNodeGroupsMutex.RLock()
	defer fake.clusterTasksForNodeGroupsMutex.RUnlock()
	fake.controlPlaneVersionMutex.RLock()
	defer fake.controlPlaneVersionMutex.RUnlock()
	fake.getUsernameMutex.RLock()
	defer fake.getUsernameMutex.RUnlock()
	fake.kubeProviderMutex.RLock()
	defer fake.kubeProviderMutex.RUnlock()
	fake.loadClusterIntoSpecFromStackMutex.RLock()
	defer fake.loadClusterIntoSpecFromStackMutex.RUnlock()
	fake.newClientMutex.RLock()
	defer fake.newClientMutex.RUnlock()
	fake.newOpenIDConnectManagerMutex.RLock()
	defer fake.newOpenIDConnectManagerMutex.RUnlock()
	fake.newRawClientMutex.RLock()
	defer fake.newRawClientMutex.RUnlock()
	fake.newStackManagerMutex.RLock()
	defer fake.newStackManagerMutex.RUnlock()
	fake.newStdClientSetMutex.RLock()
	defer fake.newStdClientSetMutex.RUnlock()
	fake.serverVersionMutex.RLock()
	defer fake.serverVersionMutex.RUnlock()
	fake.statusMutex.RLock()
	defer fake.statusMutex.RUnlock()
	fake.supportsManagedNodesMutex.RLock()
	defer fake.supportsManagedNodesMutex.RUnlock()
	fake.updateAuthConfigMapMutex.RLock()
	defer fake.updateAuthConfigMapMutex.RUnlock()
	fake.validateClusterForCompatibilityMutex.RLock()
	defer fake.validateClusterForCompatibilityMutex.RUnlock()
	fake.waitForNodesMutex.RLock()
	defer fake.waitForNodesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClusterProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ eks.ClusterProvider = new(FakeClusterProvider)
